// SudokuSolver by Will Shelver
package me.will_s.school.sudoku.solver;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/**
 * The fundamental component of the doubly circularly linked list, a Node
 * represents a connection between a constraint and a solution part that
 * satisfies it. See the methods of {@link Initialiser} and {@link Solver} for
 * use of nodes
 */
class Node {
	public HeaderNode head;
	public Node up;
	public Node down;
	public Node left;
	public Node right;
	// For Node, SolutionPart.A = row, .B = col, .C = value
	// TODO: return to private, public required for testing in Initialiser
	public short solutionPart;
	
	// Constructor time
	
	/**
	 * Basic constructor, initialises the node so all fields point to itself
	 */
	
	// All callers must set this.head
	protected Node() {
		this.head = null;
		this.up = this;
		this.down = this;
		this.left = this;
		this.right = this;
		this.solutionPart = 0;
	}
	
	/**
	 * Constructs a node with its header pointer and solution part id set
	 * 
	 * @param head
	 *            The {@link HeaderNode} representing the column that this node
	 *            belongs to
	 * @param ident
	 *            A short (generated by
	 *            {@link SolutionPart#getSolutionPart(int, int, int)} that can
	 *            be used to identify the RCV that this node represents
	 */
	public Node(HeaderNode head, short ident) {
		this();
		this.head = head;
		this.solutionPart = ident;
		head.size++;
	}
	
	/**
	 * @return The {@link SolutionPart} represented by this node
	 */
	public SolutionPart getSolutionPart() {
		return new SolutionPart(this.solutionPart);
	}
	
	/**
	 * Convenience method to return the RCV that this node represents in a
	 * human-readable form
	 * 
	 * @return The RCV, in the form "r:c:v" e.g. 1:2:3
	 */
	public String getNumberString() {
		SolutionPart part = this.getSolutionPart();
		return part.getA() + ":" + part.getB() + ":" + part.getC();
	}
	
	/**
	 * Returns the string that uniquely identifies this Node, in the form
	 * "Node [r:c:v] (number) under ([r:c:v])" (second RCV is of the column's
	 * header node)
	 */
	@Override
	public String toString() {
		String str = "Node [" + this.getNumberString() + "] ("
				+ this.solutionPart + ") under "
				+ (head.toString().split(" ")[1]);
		return str;
	}
}

/**
 * Extension of {@link Node} that serves as a column header. This type has an
 * identifier in the form of a {@link SolutionPart} that identifies the row,
 * column and value this node's column represents. It also has an integer
 * specifying the current number of nodes in the column, which is a heuristic
 * for improving the speed of the {@link Solver} methods
 */
// solutionPart.A = type (cell, row, col, value), .B = major no., .C = minor no
class HeaderNode extends Node {
	public short size;
	
	static enum ConstraintType {
		SQUARE, ROW, COLUMN, BOX;
	}
	
	protected HeaderNode() {
		super();
	}
	
	public HeaderNode(HeaderNode left, HeaderNode right, int number) {
		this.head = this;
		this.left = left;
		this.right = right;
		this.up = this;
		this.down = this;
		this.size = 0;
		this.solutionPart = (short) number;
		
		left.right = this;
		right.left = this;
	}
	
	@Override
	public String toString() {
		// String str2 = "HeaderNode "; // something useful here, maybe
		String str = "HeaderNode" + " [" + getNumberString() + "]";
		return str;
	}
}

/**
 * A special node that represents the entire list structure. It is linked
 * horizontally with the {@link HeaderNode}s, but is the only node in its
 * column.
 */
class RootNode extends HeaderNode {
	
	RootNode() {
		this.head = this;
		this.up = this;
		this.down = this;
		this.left = this;
		this.right = this;
		// this.solutionPart = 0;
		this.size = 0;
	}
	
	@Override
	public String toString() {
		return "RootNode";
	}
	
	@Override
	public String getNumberString() {
		return "root";
	}
}

/**
 * Class used to separate nodes into the rows they form, for easy access.
 * Contains a method for linking of inserted nodes.
 */
@SuppressWarnings("serial")
class Row extends ArrayList<Node> {
	public int number;
	
	public Row(int number) {
		super(4); // Rows only ever have 4 entries, save some memory
		this.number = number;
	}
	
	/**
	 * Links the nodes in this row horizontally and vertically.
	 */
	public void linkNodes() {
		// Walk the list of nodes, linking each according to its index
		for (int i = 0; i < this.size(); i++) {
			Node node = this.get(i); // Select each node in the row, left to
										// right
			// Set the right pointer to the next node in the row, or loop around
			// to the first element
			node.right = this.get((i + 1) % this.size());
			// Set the left pointer to the previous element, looping to the
			// rightmost element if necessary
			node.left = this.get(i > 0 ? i - 1 : this.size() - 1);
			
			// Let this node know what its vertical neighbours are
			node.up = node.head.up;
			node.down = node.head;
			// Let said neighbours know about this node
			node.up.down = node;
			node.down.up = node;
		}
	}
}

/**
 * Class used to hold strong references to all nodes in the list structure, to
 * prevent them being garbage collected during operation of the {@link Solver}
 * methods
 */
class NodeManager {
	final RootNode root;
	
	final Map<HeaderNode.ConstraintType, List<HeaderNode>> headers;
	final List<Row> rows;
	final Stack<Node> preExistingSolutionParts;
	
	public NodeManager() {
		this.root = new RootNode();
		this.headers = new EnumMap<HeaderNode.ConstraintType, List<HeaderNode>>(
				HeaderNode.ConstraintType.class);
		// Initialise the lists of header nodes
		for (HeaderNode.ConstraintType type : HeaderNode.ConstraintType.values()) {
			this.headers.put(type, new ArrayList<HeaderNode>(81));
		}
		this.rows = new ArrayList<Row>(729);
		this.preExistingSolutionParts = new Stack<Node>();
	}
	
	/**
	 * Method to return the header node corresponding to the satisfaction of a
	 * particular constraint
	 * 
	 * @param type
	 *            the constraint type
	 * @param a
	 *            Primary offset
	 * @param b
	 *            Secondary offset
	 * @return The header node identified by the
	 *         {@link HeaderNode.ConstraintType ConstraintType} specified by
	 *         type, at the offset specified by (9 * a + b)
	 */
	public HeaderNode getHeader(HeaderNode.ConstraintType type, int a, int b) {
		return this.headers.get(type).get(9 * a + b);
	}
}