// SudokuSolver by Will Shelver
package me.will_s.school.sudoku.solver;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/** The fundamental component of the doubly circularly linked list, a Node
 * represents a connection between a constraint and a solution part that
 * satisfies it. See the methods of {@link Initialiser} and {@link Solver} for
 * use of nodes */
class Node {
	/** The {@code HeaderNode} at the top of this node's column, representing the
	 * constraint satisfied by this node's row */
	public HeaderNode head;
	/** The node above this */
	public Node up;
	/** The node below this */
	public Node down;
	/** The node to the left of this */
	public Node left;
	/** The node to the right of this */
	public Node right;
	// For Node, SolutionPart.A = row, .B = col, .C = value
	// TODO: return to private, public required for testing in Initialiser
	/** The compressed representation of the {@link SolutionPart} represented by
	 * this node's row */
	public short solutionPart;
	
	// Constructor time
	
	/** Initialises the node so all fields point to itself */
	
	// All callers must set this.head
	protected Node() {
		this.head = null;
		this.up = this;
		this.down = this;
		this.left = this;
		this.right = this;
		this.solutionPart = 0;
	}
	
	/** Constructs a node with its header pointer and solution part id set, and
	 * the other fields set to itself
	 * 
	 * @param head
	 *            The {@link HeaderNode} representing the column that this node
	 *            belongs to
	 * @param ident
	 *            A short (generated by
	 *            {@link SolutionPart#getSolutionPart(int, int, int)} that can
	 *            be used to identify the RCV that this node represents */
	public Node(HeaderNode head, short ident) {
		this();
		this.head = head;
		this.solutionPart = ident;
		head.size++;
	}
	
	/** @return The {@link SolutionPart} represented by this node */
	public SolutionPart getSolutionPart() {
		return new SolutionPart(this.solutionPart);
	}
	
	/** Convenience method to return the RCV that this node's row represents in a
	 * human-readable form
	 * 
	 * @return The RCV, in the form "r:c:v" e.g. 1:2:3 */
	public String getNumberString() {
		SolutionPart part = this.getSolutionPart();
		return part.toString();
	}
	
	/** Returns the string that uniquely identifies this Node, in the form
	 * "Node [r:c:v] (number) under ([r:c:v])" (second RCV is of the column's
	 * header node) */
	@Override
	public String toString() {
		String str = "Node [" + this.getNumberString() + "] ("
				+ this.solutionPart + ") under "
				+ (head.toString().split(" ")[1]);
		return str;
	}
}

/** Extension of {@link Node} that serves as a column header. This type has an
 * identifier in the form of a {@link SolutionPart} that identifies the row,
 * column and value this node's column represents. It also has an integer
 * specifying the current number of nodes in the column, which is a heuristic
 * for improving the speed of the {@link Solver} methods */
// solutionPart.A = type (cell, row, col, value), .B = major no., .C = minor no
class HeaderNode extends Node {
	/** Number of {@code Nodes} in this {@code HeaderNode's} column */
	public short size;
	
	/** Enum used to identify a {@code HeaderNode} as representing a specific
	 * constraint type. */
	static enum ConstraintType {
		SQUARE, ROW, COLUMN, BOX;
	}
	
	/** Simply calls {@code super()} */
	protected HeaderNode() {
		super();
		this.size = 0;
	}
	
	/** Constructs a {@code HeaderNode} and links it in to the current circularly
	 * linked list of {@code HeaderNodes}
	 * 
	 * @param left
	 *            The {@code HeaderNode} to the left of this
	 * @param right
	 *            The {@code HeaderNode} to the right of this
	 * @param number
	 *            The compressed representation of the constraint type and
	 *            specific constraint numbers */
	public HeaderNode(HeaderNode left, HeaderNode right, int number) {
		this();
		this.head = this;
		this.left = left;
		this.right = right;
		this.solutionPart = (short) number;
		
		left.right = this;
		right.left = this;
	}
	
	@Override
	public String toString() {
		// String str2 = "HeaderNode "; // something useful here, maybe
		String str = "HeaderNode" + " [" + getNumberString() + "]";
		return str;
	}
}

/** A special node that represents the entire list structure. It is linked
 * horizontally with the {@link HeaderNode}s, but is the only node in its
 * column. */
class RootNode extends HeaderNode {
	
	/** Creates the {@code RootNode}, with its {@code head} set to itself. */
	RootNode() {
		super();
		this.head = this;
		// this.solutionPart = 0;
	}
	
	@Override
	public String toString() {
		return "RootNode";
	}
	
	@Override
	public String getNumberString() {
		return "root";
	}
}

/** Class used to separate nodes into the rows they form, for easy access.
 * Contains a method for linking of inserted nodes. */
@SuppressWarnings("serial")
class Row extends ArrayList<Node> {
	/** Row number, used for debugging. */
	public int number;
	
	/** @param number
	 *            The row number */
	public Row(int number) {
		super(4); // Rows only ever have 4 entries, save some memory
		this.number = number;
	}
	
	/** Links the nodes in this row horizontally and vertically (link each node
	 * to its neighbours in this row, and under its correct vertical
	 * neighbours). */
	public void linkNodes() {
		// Walk the list of nodes, linking each according to its index
		for (int i = 0; i < this.size(); i++) {
			Node node = this.get(i); // Select each node in the row, left to
										// right
			// Set the right pointer to the next node in the row, or loop around
			// to the first element
			node.right = this.get((i + 1) % this.size());
			// Set the left pointer to the previous element, looping to the
			// rightmost element if necessary
			node.left = this.get(i > 0 ? i - 1 : this.size() - 1);
			
			// Let this node know what its vertical neighbours are
			node.up = node.head.up;
			node.down = node.head;
			// Let said neighbours know about this node
			node.up.down = node;
			node.down.up = node;
		}
	}
}

/** Class used to hold strong references to all nodes in the list structure, to
 * prevent them being garbage collected during operation of the {@link Solver}
 * methods */
class NodeManager {
	/** The {@link RootNode} of the grid */
	final RootNode root;
	
	/** Stores the lists of {@link HeaderNode}s under their respective
	 * {@link HeaderNode.ConstraintType}s */
	final Map<HeaderNode.ConstraintType, List<HeaderNode>> headers;
	/** {@code List} of {@link Row}s */
	final List<Row> rows;
	/** {@code Stack} of solution parts that already exist because of the existing
	 * placement of values */
	final Stack<Short> existingSolutionParts;
	
	/** Constructs a new {@code NodeManager}, creating the {@code RootNode} and
	 * initialising the other fields */
	public NodeManager() {
		this.root = new RootNode();
		this.headers = new EnumMap<HeaderNode.ConstraintType, List<HeaderNode>>(
				HeaderNode.ConstraintType.class);
		// Initialise the lists of header nodes
		for (HeaderNode.ConstraintType type : HeaderNode.ConstraintType.values()) {
			this.headers.put(type, new ArrayList<HeaderNode>(81));
		}
		this.rows = new ArrayList<Row>(729);
		this.existingSolutionParts = new Stack<Short>();
	}
	
	/** Method to return the header node corresponding to a particular constraint
	 * 
	 * @param type
	 *            the constraint type
	 * @param a
	 *            Primary offset
	 * @param b
	 *            Secondary offset
	 * @return The header node identified by the
	 *         {@link HeaderNode.ConstraintType ConstraintType} specified by
	 *         type, at the offset specified by (9 * a + b) */
	public HeaderNode getHeader(HeaderNode.ConstraintType type, int a, int b) {
		return this.headers.get(type).get(9 * a + b);
	}
}